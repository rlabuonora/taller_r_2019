---
title: "Data Wrangling 2: Joins y reshape"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
library(tidyverse)
```

## Joins

Verbos para unir dos tablas:

* `left_join`, `right_join`, `full_join`
* `semi_join`, `anti_join`
* `intersect`, `union`, `setdiff`


---
## Especificar las columnas

x está en los dos $data$ $frames$.

```{r}
df1 <- data_frame(x = c(1, 2), y = 2:1)
df2 <- data_frame(x = c(1, 3), a = 10, b = "a")
df1
```
---
```{r}
df2
```

La opción `by` permite elegir los campos cuando tienen distinto nombre o hay varios que coinciden.

---
##`left_join`

Se queda con todas las filas del primer arg (`right_join` lo opuesto).

```{r}
left_join(df1, df2)
```

Pone `NA` en los que no aplican y todas las columnas.

---
##`inner_join`
Se queda con todas las filas que están en df1 que tienen un $match$ en df2 y todas las columnas de df1 y df2.

```{r}
inner_join(df1, df2)
```

---
##`full_join`

Se queda con todas las filas y columnas que están en los dos df.

```{r}
full_join(df1, df2)
```

---
##`semi_join`

Se queda con todas las filas del df1 que tienen un $match$ en df2 y las columnas de df1.

```{r}
semi_join(df1, df2)
```

---
##`anti_join`

Saca las filas de df1 que están en df2.

```{r}
anti_join(df1, df2)
```

---
##Tidy data




*"Happy families are all alike, every unhappy family is unhappy in its own way."* 
                                                                   - Leo Tolstoy

*"Tidy datasets are all alike, but every messy dataset is messy in its own way."* 
                                                                - Hadley Wickham

---
## Tidy data (2) 

- Cada observación tiene que ser una fila
- Cada variable tiene que ser una columna

```{r, message=FALSE}
library(tidyverse)
```

```{r}
table1
```


---
##Calcular la tasa de enfermos

```{r, message=FALSE}
library(tidyverse)
```

```{r}
table1 %>% 
  mutate(tasa=cases/population)
```

---
## Casos por año

```{r, message=FALSE}
library(tidyverse)
```

```{r}
table1 %>% 
  group_by(year) %>%
  summarize(n=sum(cases))
```


---
## Untidy data (3) 

```{r}
table2
```

---
## Untidy data (4) 

```{r}
table3
```

---
## Untidy data (5) 

```{r}
table4a
```
---
## Untidy data (6) 

```{r}
table4b
```
---
## Untidy data

Se pueden lograr los mismos resultados a partir del resto de las tablas. Pero si primero llevamos los datos a una forma "canónica", podemos usarlas funciones de `dplyr`.

---
## `spread`

```{r}
table2
```
---
```{r}
spread(table2, key=type, value=count )
```

---
## `gather`

```{r}
t4a <- gather(table4a,"1999","2000", key="year", value="cases")
t4b <- gather(table4b,"1999","2000", key="year", value="population")
left_join(t4a, t4b)
```

---
# Ejercicio RPAE

Abrir archivo

```{r}
marco_rpae <- readRDS('/home/rlabuonora/bases/confidencial/marco_rpae.rds')
names(marco_rpae)
```

---
Seleccionar campos: 

- rut, ine, razon_social, depto, ventas, personal_ocupado

```{r}
marco_rpae <- marco_rpae %>% 
  rename(rut=RUT, nro_ine = INE, razon_social=RSOCIAL, depto=DEPTO) %>%
  select(rut, nro_ine, razon_social, depto, matches("_20\\d{2}$"), -matches("DEPTO_"))
```

---
# Cambiar nombres
nombre de variables en minúscula
```{r}
names(marco_rpae) <- tolower(names(marco_rpae))
```

---
#Tidy - Paso 1


Gather con todas las variables que terminan en cuatro dígitos.
```{r}
# tidy con los años
marco_rpae_tidy <- marco_rpae %>% 
  gather(var, val, matches("_\\d{4}$"))
```
---
# Paso 2 - Separar

```{r}
marco_rpae_tidy <- marco_rpae_tidy %>%
   separate(var, into=c("variable", "year"))
head(marco_rpae_tidy)
```

---
# Paso 3 - Spread 

```{r}
marco_rpae_tidy <- marco_rpae_tidy %>%
    spread(variable, val)
head(marco_rpae_tidy)
```

---
# Cambiar NaN por NA

```{r}
sacarNans <- function(x) {
  if_else(is.nan((x)), NA_real_, x)
}

marco_rpae_tidy <- marco_rpae_tidy %>%
  mutate_if(is.numeric, funs(sacarNans(.)))

marco_rpae_tidy
```

# Votacion

Un experimento de votación con varios "grupos" (hawthorne, civicduty, neighbors, self)
```{r}
gerber <- readRDS("data/gerber.rds")
str(gerber)
```

---
Quiero sacar la proporción de cuántos votan por grupo.
Votacion


¿Cuál sería la forma tidy de este juego de datos?

```{r}
gerber_tidy <- gerber %>% 
  gather(group, sacar, hawthorne, civicduty, neighbors, self) 
head(gerber_tidy)
```
---
# Votacion

```{r}
gerber_tidy %>%
  filter(sacar == 1) %>%
  select(-sacar) %>%
  group_by(group) %>%
  summarize(mean_voting = mean(voting))
```
